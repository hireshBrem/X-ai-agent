"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-stick-to-bottom";
exports.ids = ["vendor-chunks/use-stick-to-bottom"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-stick-to-bottom/dist/StickToBottom.js":
/*!****************************************************************!*\
  !*** ./node_modules/use-stick-to-bottom/dist/StickToBottom.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StickToBottom: () => (/* binding */ StickToBottom),\n/* harmony export */   useStickToBottomContext: () => (/* binding */ useStickToBottomContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useStickToBottom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useStickToBottom.js */ \"(ssr)/./node_modules/use-stick-to-bottom/dist/useStickToBottom.js\");\n\n/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nconst StickToBottomContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction StickToBottom({ instance, children, resize, initial, mass, damping, stiffness, targetScrollTop: currentTargetScrollTop, contextRef, ...props }) {\n    const targetScrollTop = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((target, elements) => {\n        const get = context.targetScrollTop ?? currentTargetScrollTop;\n        return get?.(target, elements) ?? target;\n    }, [currentTargetScrollTop]);\n    const defaultInstance = (0,_useStickToBottom_js__WEBPACK_IMPORTED_MODULE_2__.useStickToBottom)({\n        mass,\n        damping,\n        stiffness,\n        resize,\n        initial,\n        targetScrollTop,\n    });\n    const { scrollRef, contentRef, scrollToBottom, stopScroll, isAtBottom, isNearBottom, escapedFromLock, state, } = instance ?? defaultInstance;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n        scrollToBottom,\n        stopScroll,\n        scrollRef,\n        isAtBottom,\n        isNearBottom,\n        escapedFromLock,\n        contentRef,\n        state,\n    }), [\n        scrollToBottom,\n        isAtBottom,\n        contentRef,\n        isNearBottom,\n        scrollRef,\n        stopScroll,\n        escapedFromLock,\n        state,\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(contextRef, () => context, [context]);\n    useIsomorphicLayoutEffect(() => {\n        if (!scrollRef.current) {\n            return;\n        }\n        if (getComputedStyle(scrollRef.current).overflow === \"visible\") {\n            scrollRef.current.style.overflow = \"auto\";\n        }\n    }, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StickToBottomContext.Provider, { value: context, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...props, children: typeof children === \"function\" ? children(context) : children }) }));\n}\n(function (StickToBottom) {\n    function Content({ children, ...props }) {\n        const context = useStickToBottomContext();\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: context.scrollRef, style: {\n                height: \"100%\",\n                width: \"100%\",\n            }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...props, ref: context.contentRef, children: typeof children === \"function\" ? children(context) : children }) }));\n    }\n    StickToBottom.Content = Content;\n})(StickToBottom || (StickToBottom = {}));\n/**\n * Use this hook inside a <StickToBottom> component to gain access to whether the component is at the bottom of the scrollable area.\n */\nfunction useStickToBottomContext() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StickToBottomContext);\n    if (!context) {\n        throw new Error(\"use-stick-to-bottom component context must be used within a StickToBottom component\");\n    }\n    return context;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLXN0aWNrLXRvLWJvdHRvbS9kaXN0L1N0aWNrVG9Cb3R0b20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDK0I7QUFDOEU7QUFDbkQ7QUFDMUQsNkJBQTZCLG9EQUFhO0FBQzFDLGtFQUFrRSxrREFBZSxHQUFHLDRDQUFTO0FBQ3RGLHlCQUF5Qiw4SEFBOEg7QUFDOUosNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixzRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksdUdBQXVHO0FBQ25ILG9CQUFvQiw4Q0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksc0RBQUksa0NBQWtDLDBCQUEwQixzREFBSSxVQUFVLG1GQUFtRixHQUFHO0FBQ2hMO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0EsZ0JBQWdCLHNEQUFJLFVBQVU7QUFDOUI7QUFDQTtBQUNBLGFBQWEsWUFBWSxzREFBSSxVQUFVLDRHQUE0RyxHQUFHO0FBQ3RKO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixpREFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaGlyZXNoYi9Eb2N1bWVudHMvY29kaW5nL3NpZGUtcHJvamVjdHMvWC1Ccm93c2VyLUFnZW50L2NsaWVudC9ub2RlX21vZHVsZXMvdXNlLXN0aWNrLXRvLWJvdHRvbS9kaXN0L1N0aWNrVG9Cb3R0b20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbi8qIS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgU3RhY2tCbGl0ei4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vLCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RpY2tUb0JvdHRvbSwgfSBmcm9tIFwiLi91c2VTdGlja1RvQm90dG9tLmpzXCI7XG5jb25zdCBTdGlja1RvQm90dG9tQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbmV4cG9ydCBmdW5jdGlvbiBTdGlja1RvQm90dG9tKHsgaW5zdGFuY2UsIGNoaWxkcmVuLCByZXNpemUsIGluaXRpYWwsIG1hc3MsIGRhbXBpbmcsIHN0aWZmbmVzcywgdGFyZ2V0U2Nyb2xsVG9wOiBjdXJyZW50VGFyZ2V0U2Nyb2xsVG9wLCBjb250ZXh0UmVmLCAuLi5wcm9wcyB9KSB7XG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsVG9wID0gUmVhY3QudXNlQ2FsbGJhY2soKHRhcmdldCwgZWxlbWVudHMpID0+IHtcbiAgICAgICAgY29uc3QgZ2V0ID0gY29udGV4dC50YXJnZXRTY3JvbGxUb3AgPz8gY3VycmVudFRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgcmV0dXJuIGdldD8uKHRhcmdldCwgZWxlbWVudHMpID8/IHRhcmdldDtcbiAgICB9LCBbY3VycmVudFRhcmdldFNjcm9sbFRvcF0pO1xuICAgIGNvbnN0IGRlZmF1bHRJbnN0YW5jZSA9IHVzZVN0aWNrVG9Cb3R0b20oe1xuICAgICAgICBtYXNzLFxuICAgICAgICBkYW1waW5nLFxuICAgICAgICBzdGlmZm5lc3MsXG4gICAgICAgIHJlc2l6ZSxcbiAgICAgICAgaW5pdGlhbCxcbiAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgc2Nyb2xsUmVmLCBjb250ZW50UmVmLCBzY3JvbGxUb0JvdHRvbSwgc3RvcFNjcm9sbCwgaXNBdEJvdHRvbSwgaXNOZWFyQm90dG9tLCBlc2NhcGVkRnJvbUxvY2ssIHN0YXRlLCB9ID0gaW5zdGFuY2UgPz8gZGVmYXVsdEluc3RhbmNlO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHNjcm9sbFRvQm90dG9tLFxuICAgICAgICBzdG9wU2Nyb2xsLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIGlzQXRCb3R0b20sXG4gICAgICAgIGlzTmVhckJvdHRvbSxcbiAgICAgICAgZXNjYXBlZEZyb21Mb2NrLFxuICAgICAgICBjb250ZW50UmVmLFxuICAgICAgICBzdGF0ZSxcbiAgICB9KSwgW1xuICAgICAgICBzY3JvbGxUb0JvdHRvbSxcbiAgICAgICAgaXNBdEJvdHRvbSxcbiAgICAgICAgY29udGVudFJlZixcbiAgICAgICAgaXNOZWFyQm90dG9tLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHN0b3BTY3JvbGwsXG4gICAgICAgIGVzY2FwZWRGcm9tTG9jayxcbiAgICAgICAgc3RhdGUsXG4gICAgXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShjb250ZXh0UmVmLCAoKSA9PiBjb250ZXh0LCBbY29udGV4dF0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNjcm9sbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoc2Nyb2xsUmVmLmN1cnJlbnQpLm92ZXJmbG93ID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIjtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKF9qc3goU3RpY2tUb0JvdHRvbUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBfanN4KFwiZGl2XCIsIHsgLi4ucHJvcHMsIGNoaWxkcmVuOiB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGNvbnRleHQpIDogY2hpbGRyZW4gfSkgfSkpO1xufVxuKGZ1bmN0aW9uIChTdGlja1RvQm90dG9tKSB7XG4gICAgZnVuY3Rpb24gQ29udGVudCh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9KSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTdGlja1RvQm90dG9tQ29udGV4dCgpO1xuICAgICAgICByZXR1cm4gKF9qc3goXCJkaXZcIiwgeyByZWY6IGNvbnRleHQuc2Nyb2xsUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IF9qc3goXCJkaXZcIiwgeyAuLi5wcm9wcywgcmVmOiBjb250ZXh0LmNvbnRlbnRSZWYsIGNoaWxkcmVuOiB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGNvbnRleHQpIDogY2hpbGRyZW4gfSkgfSkpO1xuICAgIH1cbiAgICBTdGlja1RvQm90dG9tLkNvbnRlbnQgPSBDb250ZW50O1xufSkoU3RpY2tUb0JvdHRvbSB8fCAoU3RpY2tUb0JvdHRvbSA9IHt9KSk7XG4vKipcbiAqIFVzZSB0aGlzIGhvb2sgaW5zaWRlIGEgPFN0aWNrVG9Cb3R0b20+IGNvbXBvbmVudCB0byBnYWluIGFjY2VzcyB0byB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgc2Nyb2xsYWJsZSBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RpY2tUb0JvdHRvbUNvbnRleHQoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoU3RpY2tUb0JvdHRvbUNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2Utc3RpY2stdG8tYm90dG9tIGNvbXBvbmVudCBjb250ZXh0IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBTdGlja1RvQm90dG9tIGNvbXBvbmVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-stick-to-bottom/dist/StickToBottom.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-stick-to-bottom/dist/useStickToBottom.js":
/*!*******************************************************************!*\
  !*** ./node_modules/use-stick-to-bottom/dist/useStickToBottom.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStickToBottom: () => (/* binding */ useStickToBottom)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst DEFAULT_SPRING_ANIMATION = {\n    /**\n     * A value from 0 to 1, on how much to damp the animation.\n     * 0 means no damping, 1 means full damping.\n     *\n     * @default 0.7\n     */\n    damping: 0.7,\n    /**\n     * The stiffness of how fast/slow the animation gets up to speed.\n     *\n     * @default 0.05\n     */\n    stiffness: 0.05,\n    /**\n     * The inertial mass associated with the animation.\n     * Higher numbers make the animation slower.\n     *\n     * @default 1.25\n     */\n    mass: 1.25,\n};\nconst STICK_TO_BOTTOM_OFFSET_PX = 70;\nconst SIXTY_FPS_INTERVAL_MS = 1000 / 60;\nconst RETAIN_ANIMATION_DURATION_MS = 350;\nconst useStickToBottom = (options = {}) => {\n    const [escapedFromLock, updateEscapedFromLock] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isAtBottom, updateIsAtBottom] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(options.initial !== false);\n    const [isNearBottom, setIsNearBottom] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    optionsRef.current = options;\n    const setIsAtBottom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isAtBottom) => {\n        state.isAtBottom = isAtBottom;\n        updateIsAtBottom(isAtBottom);\n    }, []);\n    const setEscapedFromLock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((escapedFromLock) => {\n        state.escapedFromLock = escapedFromLock;\n        updateEscapedFromLock(escapedFromLock);\n    }, []);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        let lastCalculation;\n        return {\n            escapedFromLock,\n            isAtBottom,\n            resizeDifference: 0,\n            accumulated: 0,\n            velocity: 0,\n            listeners: new Set(),\n            get scrollTop() {\n                return scrollRef.current?.scrollTop ?? 0;\n            },\n            set scrollTop(scrollTop) {\n                if (scrollRef.current) {\n                    scrollRef.current.scrollTop = scrollTop;\n                    state.ignoreScrollToTop = scrollRef.current.scrollTop;\n                }\n            },\n            get targetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                return (scrollRef.current.scrollHeight - 1 - scrollRef.current.clientHeight);\n            },\n            get calculatedTargetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                const { targetScrollTop } = this;\n                if (!options.targetScrollTop) {\n                    return targetScrollTop;\n                }\n                if (lastCalculation?.targetScrollTop === targetScrollTop) {\n                    return lastCalculation.calculatedScrollTop;\n                }\n                const calculatedScrollTop = Math.max(Math.min(options.targetScrollTop(targetScrollTop, {\n                    scrollElement: scrollRef.current,\n                    contentElement: contentRef.current,\n                }), targetScrollTop), 0);\n                lastCalculation = { targetScrollTop, calculatedScrollTop };\n                requestAnimationFrame(() => {\n                    lastCalculation = undefined;\n                });\n                return calculatedScrollTop;\n            },\n            get scrollDifference() {\n                return this.calculatedTargetScrollTop - this.scrollTop;\n            },\n            get isNearBottom() {\n                return this.scrollDifference <= STICK_TO_BOTTOM_OFFSET_PX;\n            },\n        };\n    }, []);\n    const scrollToBottom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((scrollOptions = {}) => {\n        if (typeof scrollOptions === \"string\") {\n            scrollOptions = { animation: scrollOptions };\n        }\n        if (!scrollOptions.preserveScrollPosition) {\n            setIsAtBottom(true);\n        }\n        const waitElapsed = Date.now() + (Number(scrollOptions.wait) || 0);\n        const behavior = mergeAnimations(optionsRef.current, scrollOptions.animation);\n        const { ignoreEscapes = false } = scrollOptions;\n        let durationElapsed;\n        let startTarget = state.calculatedTargetScrollTop;\n        if (scrollOptions.duration instanceof Promise) {\n            scrollOptions.duration.finally(() => {\n                durationElapsed = Date.now();\n            });\n        }\n        else {\n            durationElapsed = waitElapsed + (scrollOptions.duration ?? 0);\n        }\n        const next = async () => {\n            const promise = new Promise(requestAnimationFrame).then(() => {\n                if (!state.isAtBottom) {\n                    state.animation = undefined;\n                    return false;\n                }\n                const { scrollTop } = state;\n                const tick = performance.now();\n                const tickDelta = (tick - (state.lastTick ?? tick)) / SIXTY_FPS_INTERVAL_MS;\n                state.animation || (state.animation = { behavior, promise, ignoreEscapes });\n                if (state.animation.behavior === behavior) {\n                    state.lastTick = tick;\n                }\n                if (waitElapsed > Date.now()) {\n                    return next();\n                }\n                if (scrollTop < Math.min(startTarget, state.calculatedTargetScrollTop)) {\n                    if (state.animation?.behavior === behavior) {\n                        if (behavior === \"instant\") {\n                            state.scrollTop = state.calculatedTargetScrollTop;\n                            return next();\n                        }\n                        state.velocity =\n                            (behavior.damping * state.velocity +\n                                behavior.stiffness * state.scrollDifference) /\n                                behavior.mass;\n                        state.accumulated += state.velocity * tickDelta;\n                        state.scrollTop += state.accumulated;\n                        if (state.scrollTop !== scrollTop) {\n                            state.accumulated = 0;\n                        }\n                    }\n                    return next();\n                }\n                if (durationElapsed > Date.now()) {\n                    startTarget = state.calculatedTargetScrollTop;\n                    return next();\n                }\n                state.animation = undefined;\n                /**\n                 * If we're still below the target, then queue\n                 * up another scroll to the bottom with the last\n                 * requested animatino.\n                 */\n                if (state.scrollTop < state.calculatedTargetScrollTop) {\n                    return scrollToBottom({\n                        animation: mergeAnimations(optionsRef.current, optionsRef.current.resize),\n                        ignoreEscapes,\n                        duration: Math.max(0, durationElapsed - Date.now()) || undefined,\n                    });\n                }\n                return state.isAtBottom;\n            });\n            return promise.then((isAtBottom) => {\n                requestAnimationFrame(() => {\n                    if (!state.animation) {\n                        state.lastTick = undefined;\n                        state.velocity = 0;\n                    }\n                });\n                return isAtBottom;\n            });\n        };\n        if (scrollOptions.wait !== true) {\n            state.animation = undefined;\n        }\n        if (state.animation?.behavior === behavior) {\n            return state.animation.promise;\n        }\n        return next();\n    }, [setIsAtBottom, state]);\n    const stopScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setEscapedFromLock(true);\n        setIsAtBottom(false);\n    }, [setEscapedFromLock, setIsAtBottom]);\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ target }) => {\n        if (target !== scrollRef.current) {\n            return;\n        }\n        const { scrollTop, ignoreScrollToTop } = state;\n        let { lastScrollTop = scrollTop } = state;\n        state.lastScrollTop = scrollTop;\n        state.ignoreScrollToTop = undefined;\n        if (ignoreScrollToTop && ignoreScrollToTop > scrollTop) {\n            /**\n             * When the user scrolls up while the animation plays, the `scrollTop` may\n             * not come in separate events; if this happens, to make sure `isScrollingUp`\n             * is correct, set the lastScrollTop to the ignored event.\n             */\n            lastScrollTop = ignoreScrollToTop;\n        }\n        setIsNearBottom(state.isNearBottom);\n        /**\n         * Scroll events may come before a ResizeObserver event,\n         * so in order to ignore resize events correctly we use a\n         * timeout.\n         *\n         * @see https://github.com/WICG/resize-observer/issues/25#issuecomment-248757228\n         */\n        setTimeout(() => {\n            /**\n             * When theres a resize difference ignore the resize event.\n             */\n            if (state.resizeDifference || scrollTop === ignoreScrollToTop) {\n                return;\n            }\n            const isScrollingDown = scrollTop > lastScrollTop;\n            const isScrollingUp = scrollTop < lastScrollTop;\n            if (state.animation?.ignoreEscapes) {\n                state.scrollTop = lastScrollTop;\n                return;\n            }\n            if (isScrollingUp) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n            }\n            if (isScrollingDown) {\n                setEscapedFromLock(false);\n            }\n            if (!state.escapedFromLock && state.isNearBottom) {\n                setIsAtBottom(true);\n            }\n        }, 1);\n    }, [setEscapedFromLock, setIsAtBottom, state]);\n    const handleWheel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ target, deltaY }) => {\n        let element = target;\n        while (![\"scroll\", \"auto\"].includes(getComputedStyle(element).overflow)) {\n            if (!element.parentElement) {\n                return;\n            }\n            element = element.parentElement;\n        }\n        /**\n         * The browser may cancel the scrolling from the mouse wheel\n         * if we update it from the animation in meantime.\n         * To prevent this, always escape when the wheel is scrolled up.\n         */\n        if (element === scrollRef.current &&\n            deltaY < 0 &&\n            scrollRef.current.scrollHeight > scrollRef.current.clientHeight &&\n            !state.animation?.ignoreEscapes) {\n            setEscapedFromLock(true);\n            setIsAtBottom(false);\n        }\n    }, [setEscapedFromLock, setIsAtBottom, state]);\n    const scrollRef = useRefCallback((scroll) => {\n        scrollRef.current?.removeEventListener(\"scroll\", handleScroll);\n        scrollRef.current?.removeEventListener(\"wheel\", handleWheel);\n        scroll?.addEventListener(\"scroll\", handleScroll, { passive: true });\n        scroll?.addEventListener(\"wheel\", handleWheel, { passive: true });\n    }, []);\n    const contentRef = useRefCallback((content) => {\n        state.resizeObserver?.disconnect();\n        if (!content) {\n            return;\n        }\n        let previousHeight;\n        state.resizeObserver = new ResizeObserver(([entry]) => {\n            const { height } = entry.contentRect;\n            const difference = height - (previousHeight ?? height);\n            state.resizeDifference = difference;\n            /**\n             * Sometimes the browser can overscroll past the target,\n             * so check for this and adjust appropriately.\n             */\n            if (state.scrollTop > state.targetScrollTop) {\n                state.scrollTop = state.targetScrollTop;\n            }\n            setIsNearBottom(state.isNearBottom);\n            if (difference >= 0) {\n                /**\n                 * If it's a positive resize, scroll to the bottom when\n                 * we're already at the bottom.\n                 */\n                const animation = mergeAnimations(optionsRef.current, previousHeight\n                    ? optionsRef.current.resize\n                    : optionsRef.current.initial);\n                scrollToBottom({\n                    animation,\n                    wait: true,\n                    preserveScrollPosition: true,\n                    duration: animation === \"instant\" ? undefined : RETAIN_ANIMATION_DURATION_MS,\n                });\n            }\n            else {\n                /**\n                 * Else if it's a negative resize, check if we're near the bottom\n                 * if we are want to un-escape from the lock, because the resize\n                 * could have caused the container to be at the bottom.\n                 */\n                if (state.isNearBottom) {\n                    setEscapedFromLock(false);\n                    setIsAtBottom(true);\n                }\n            }\n            previousHeight = height;\n            /**\n             * Reset the resize difference after the scroll event\n             * has fired. Requires a rAF to wait for the scroll event,\n             * and a setTimeout to wait for the other timeout we have in\n             * resizeObserver in case the scroll event happens after the\n             * resize event.\n             */\n            requestAnimationFrame(() => {\n                setTimeout(() => {\n                    if (state.resizeDifference === difference) {\n                        state.resizeDifference = 0;\n                    }\n                }, 1);\n            });\n        });\n        state.resizeObserver?.observe(content);\n    }, []);\n    return {\n        contentRef,\n        scrollRef,\n        scrollToBottom,\n        stopScroll,\n        isAtBottom: isAtBottom || isNearBottom,\n        isNearBottom,\n        escapedFromLock,\n        state,\n    };\n};\nfunction useRefCallback(callback, deps) {\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ref) => {\n        result.current = ref;\n        return callback(ref);\n    }, deps);\n    return result;\n}\nconst animationCache = new Map();\nfunction mergeAnimations(...animations) {\n    const result = { ...DEFAULT_SPRING_ANIMATION };\n    let instant = false;\n    for (const animation of animations) {\n        if (animation === \"instant\") {\n            instant = true;\n            continue;\n        }\n        if (typeof animation !== \"object\") {\n            continue;\n        }\n        instant = false;\n        result.damping = animation.damping ?? result.damping;\n        result.stiffness = animation.stiffness ?? result.stiffness;\n        result.mass = animation.mass ?? result.mass;\n    }\n    const key = JSON.stringify(result);\n    if (!animationCache.has(key)) {\n        animationCache.set(key, Object.freeze(result));\n    }\n    return instant ? \"instant\" : animationCache.get(key);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLXN0aWNrLXRvLWJvdHRvbS9kaXN0L3VzZVN0aWNrVG9Cb3R0b20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxxREFBcUQsK0NBQVE7QUFDN0QsMkNBQTJDLCtDQUFRO0FBQ25ELDRDQUE0QywrQ0FBUTtBQUNwRCx1QkFBdUIsNkNBQU07QUFDN0I7QUFDQSwwQkFBMEIsa0RBQVc7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0Isa0RBQVc7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQiw4Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLGtEQUFXLG9CQUFvQjtBQUMxRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0Esd0RBQXdELGtDQUFrQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsa0RBQVcsSUFBSSxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCx3QkFBd0Isa0RBQVcsSUFBSSxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGVBQWU7QUFDMUUseURBQXlELGVBQWU7QUFDeEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2hpcmVzaGIvRG9jdW1lbnRzL2NvZGluZy9zaWRlLXByb2plY3RzL1gtQnJvd3Nlci1BZ2VudC9jbGllbnQvbm9kZV9tb2R1bGVzL3VzZS1zdGljay10by1ib3R0b20vZGlzdC91c2VTdGlja1RvQm90dG9tLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgU3RhY2tCbGl0ei4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSwgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IERFRkFVTFRfU1BSSU5HX0FOSU1BVElPTiA9IHtcbiAgICAvKipcbiAgICAgKiBBIHZhbHVlIGZyb20gMCB0byAxLCBvbiBob3cgbXVjaCB0byBkYW1wIHRoZSBhbmltYXRpb24uXG4gICAgICogMCBtZWFucyBubyBkYW1waW5nLCAxIG1lYW5zIGZ1bGwgZGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDAuN1xuICAgICAqL1xuICAgIGRhbXBpbmc6IDAuNyxcbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIG9mIGhvdyBmYXN0L3Nsb3cgdGhlIGFuaW1hdGlvbiBnZXRzIHVwIHRvIHNwZWVkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgMC4wNVxuICAgICAqL1xuICAgIHN0aWZmbmVzczogMC4wNSxcbiAgICAvKipcbiAgICAgKiBUaGUgaW5lcnRpYWwgbWFzcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBIaWdoZXIgbnVtYmVycyBtYWtlIHRoZSBhbmltYXRpb24gc2xvd2VyLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgMS4yNVxuICAgICAqL1xuICAgIG1hc3M6IDEuMjUsXG59O1xuY29uc3QgU1RJQ0tfVE9fQk9UVE9NX09GRlNFVF9QWCA9IDcwO1xuY29uc3QgU0lYVFlfRlBTX0lOVEVSVkFMX01TID0gMTAwMCAvIDYwO1xuY29uc3QgUkVUQUlOX0FOSU1BVElPTl9EVVJBVElPTl9NUyA9IDM1MDtcbmV4cG9ydCBjb25zdCB1c2VTdGlja1RvQm90dG9tID0gKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IFtlc2NhcGVkRnJvbUxvY2ssIHVwZGF0ZUVzY2FwZWRGcm9tTG9ja10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzQXRCb3R0b20sIHVwZGF0ZUlzQXRCb3R0b21dID0gdXNlU3RhdGUob3B0aW9ucy5pbml0aWFsICE9PSBmYWxzZSk7XG4gICAgY29uc3QgW2lzTmVhckJvdHRvbSwgc2V0SXNOZWFyQm90dG9tXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvcHRpb25zUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIG9wdGlvbnNSZWYuY3VycmVudCA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2V0SXNBdEJvdHRvbSA9IHVzZUNhbGxiYWNrKChpc0F0Qm90dG9tKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzQXRCb3R0b20gPSBpc0F0Qm90dG9tO1xuICAgICAgICB1cGRhdGVJc0F0Qm90dG9tKGlzQXRCb3R0b20pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzZXRFc2NhcGVkRnJvbUxvY2sgPSB1c2VDYWxsYmFjaygoZXNjYXBlZEZyb21Mb2NrKSA9PiB7XG4gICAgICAgIHN0YXRlLmVzY2FwZWRGcm9tTG9jayA9IGVzY2FwZWRGcm9tTG9jaztcbiAgICAgICAgdXBkYXRlRXNjYXBlZEZyb21Mb2NrKGVzY2FwZWRGcm9tTG9jayk7XG4gICAgfSwgW10pO1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IG5vdCBuZWVkZWRcbiAgICBjb25zdCBzdGF0ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgbGFzdENhbGN1bGF0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXNjYXBlZEZyb21Mb2NrLFxuICAgICAgICAgICAgaXNBdEJvdHRvbSxcbiAgICAgICAgICAgIHJlc2l6ZURpZmZlcmVuY2U6IDAsXG4gICAgICAgICAgICBhY2N1bXVsYXRlZDogMCxcbiAgICAgICAgICAgIHZlbG9jaXR5OiAwLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBnZXQgc2Nyb2xsVG9wKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxSZWYuY3VycmVudD8uc2Nyb2xsVG9wID8/IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IHNjcm9sbFRvcChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVTY3JvbGxUb1RvcCA9IHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRhcmdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjcm9sbFJlZi5jdXJyZW50IHx8ICFjb250ZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsSGVpZ2h0IC0gMSAtIHNjcm9sbFJlZi5jdXJyZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNhbGN1bGF0ZWRUYXJnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxSZWYuY3VycmVudCB8fCAhY29udGVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhcmdldFNjcm9sbFRvcCB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudGFyZ2V0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2FsY3VsYXRpb24/LnRhcmdldFNjcm9sbFRvcCA9PT0gdGFyZ2V0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0Q2FsY3VsYXRpb24uY2FsY3VsYXRlZFNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZFNjcm9sbFRvcCA9IE1hdGgubWF4KE1hdGgubWluKG9wdGlvbnMudGFyZ2V0U2Nyb2xsVG9wKHRhcmdldFNjcm9sbFRvcCwge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbGVtZW50OiBzY3JvbGxSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnQ6IGNvbnRlbnRSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICB9KSwgdGFyZ2V0U2Nyb2xsVG9wKSwgMCk7XG4gICAgICAgICAgICAgICAgbGFzdENhbGN1bGF0aW9uID0geyB0YXJnZXRTY3JvbGxUb3AsIGNhbGN1bGF0ZWRTY3JvbGxUb3AgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2FsY3VsYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRTY3JvbGxUb3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHNjcm9sbERpZmZlcmVuY2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlZFRhcmdldFNjcm9sbFRvcCAtIHRoaXMuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBpc05lYXJCb3R0b20oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRGlmZmVyZW5jZSA8PSBTVElDS19UT19CT1RUT01fT0ZGU0VUX1BYO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSB1c2VDYWxsYmFjaygoc2Nyb2xsT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsT3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2Nyb2xsT3B0aW9ucyA9IHsgYW5pbWF0aW9uOiBzY3JvbGxPcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY3JvbGxPcHRpb25zLnByZXNlcnZlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHNldElzQXRCb3R0b20odHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FpdEVsYXBzZWQgPSBEYXRlLm5vdygpICsgKE51bWJlcihzY3JvbGxPcHRpb25zLndhaXQpIHx8IDApO1xuICAgICAgICBjb25zdCBiZWhhdmlvciA9IG1lcmdlQW5pbWF0aW9ucyhvcHRpb25zUmVmLmN1cnJlbnQsIHNjcm9sbE9wdGlvbnMuYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc3QgeyBpZ25vcmVFc2NhcGVzID0gZmFsc2UgfSA9IHNjcm9sbE9wdGlvbnM7XG4gICAgICAgIGxldCBkdXJhdGlvbkVsYXBzZWQ7XG4gICAgICAgIGxldCBzdGFydFRhcmdldCA9IHN0YXRlLmNhbGN1bGF0ZWRUYXJnZXRTY3JvbGxUb3A7XG4gICAgICAgIGlmIChzY3JvbGxPcHRpb25zLmR1cmF0aW9uIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgc2Nyb2xsT3B0aW9ucy5kdXJhdGlvbi5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbkVsYXBzZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbkVsYXBzZWQgPSB3YWl0RWxhcHNlZCArIChzY3JvbGxPcHRpb25zLmR1cmF0aW9uID8/IDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVxdWVzdEFuaW1hdGlvbkZyYW1lKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzQXRCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja0RlbHRhID0gKHRpY2sgLSAoc3RhdGUubGFzdFRpY2sgPz8gdGljaykpIC8gU0lYVFlfRlBTX0lOVEVSVkFMX01TO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFuaW1hdGlvbiB8fCAoc3RhdGUuYW5pbWF0aW9uID0geyBiZWhhdmlvciwgcHJvbWlzZSwgaWdub3JlRXNjYXBlcyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYW5pbWF0aW9uLmJlaGF2aW9yID09PSBiZWhhdmlvcikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0VGljayA9IHRpY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YWl0RWxhcHNlZCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA8IE1hdGgubWluKHN0YXJ0VGFyZ2V0LCBzdGF0ZS5jYWxjdWxhdGVkVGFyZ2V0U2Nyb2xsVG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYW5pbWF0aW9uPy5iZWhhdmlvciA9PT0gYmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJpbnN0YW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zY3JvbGxUb3AgPSBzdGF0ZS5jYWxjdWxhdGVkVGFyZ2V0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52ZWxvY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJlaGF2aW9yLmRhbXBpbmcgKiBzdGF0ZS52ZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yLnN0aWZmbmVzcyAqIHN0YXRlLnNjcm9sbERpZmZlcmVuY2UpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3IubWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmFjY3VtdWxhdGVkICs9IHN0YXRlLnZlbG9jaXR5ICogdGlja0RlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2Nyb2xsVG9wICs9IHN0YXRlLmFjY3VtdWxhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWNjdW11bGF0ZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbkVsYXBzZWQgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGFyZ2V0ID0gc3RhdGUuY2FsY3VsYXRlZFRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIHN0aWxsIGJlbG93IHRoZSB0YXJnZXQsIHRoZW4gcXVldWVcbiAgICAgICAgICAgICAgICAgKiB1cCBhbm90aGVyIHNjcm9sbCB0byB0aGUgYm90dG9tIHdpdGggdGhlIGxhc3RcbiAgICAgICAgICAgICAgICAgKiByZXF1ZXN0ZWQgYW5pbWF0aW5vLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zY3JvbGxUb3AgPCBzdGF0ZS5jYWxjdWxhdGVkVGFyZ2V0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb0JvdHRvbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IG1lcmdlQW5pbWF0aW9ucyhvcHRpb25zUmVmLmN1cnJlbnQsIG9wdGlvbnNSZWYuY3VycmVudC5yZXNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlRXNjYXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLm1heCgwLCBkdXJhdGlvbkVsYXBzZWQgLSBEYXRlLm5vdygpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuaXNBdEJvdHRvbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoaXNBdEJvdHRvbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0VGljayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0F0Qm90dG9tO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY3JvbGxPcHRpb25zLndhaXQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuYW5pbWF0aW9uPy5iZWhhdmlvciA9PT0gYmVoYXZpb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5hbmltYXRpb24ucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0sIFtzZXRJc0F0Qm90dG9tLCBzdGF0ZV0pO1xuICAgIGNvbnN0IHN0b3BTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldEVzY2FwZWRGcm9tTG9jayh0cnVlKTtcbiAgICAgICAgc2V0SXNBdEJvdHRvbShmYWxzZSk7XG4gICAgfSwgW3NldEVzY2FwZWRGcm9tTG9jaywgc2V0SXNBdEJvdHRvbV0pO1xuICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHVzZUNhbGxiYWNrKCh7IHRhcmdldCB9KSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHNjcm9sbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIGlnbm9yZVNjcm9sbFRvVG9wIH0gPSBzdGF0ZTtcbiAgICAgICAgbGV0IHsgbGFzdFNjcm9sbFRvcCA9IHNjcm9sbFRvcCB9ID0gc3RhdGU7XG4gICAgICAgIHN0YXRlLmxhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIHN0YXRlLmlnbm9yZVNjcm9sbFRvVG9wID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaWdub3JlU2Nyb2xsVG9Ub3AgJiYgaWdub3JlU2Nyb2xsVG9Ub3AgPiBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgdXNlciBzY3JvbGxzIHVwIHdoaWxlIHRoZSBhbmltYXRpb24gcGxheXMsIHRoZSBgc2Nyb2xsVG9wYCBtYXlcbiAgICAgICAgICAgICAqIG5vdCBjb21lIGluIHNlcGFyYXRlIGV2ZW50czsgaWYgdGhpcyBoYXBwZW5zLCB0byBtYWtlIHN1cmUgYGlzU2Nyb2xsaW5nVXBgXG4gICAgICAgICAgICAgKiBpcyBjb3JyZWN0LCBzZXQgdGhlIGxhc3RTY3JvbGxUb3AgdG8gdGhlIGlnbm9yZWQgZXZlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxhc3RTY3JvbGxUb3AgPSBpZ25vcmVTY3JvbGxUb1RvcDtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc05lYXJCb3R0b20oc3RhdGUuaXNOZWFyQm90dG9tKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjcm9sbCBldmVudHMgbWF5IGNvbWUgYmVmb3JlIGEgUmVzaXplT2JzZXJ2ZXIgZXZlbnQsXG4gICAgICAgICAqIHNvIGluIG9yZGVyIHRvIGlnbm9yZSByZXNpemUgZXZlbnRzIGNvcnJlY3RseSB3ZSB1c2UgYVxuICAgICAgICAgKiB0aW1lb3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL3Jlc2l6ZS1vYnNlcnZlci9pc3N1ZXMvMjUjaXNzdWVjb21tZW50LTI0ODc1NzIyOFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gdGhlcmVzIGEgcmVzaXplIGRpZmZlcmVuY2UgaWdub3JlIHRoZSByZXNpemUgZXZlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXNpemVEaWZmZXJlbmNlIHx8IHNjcm9sbFRvcCA9PT0gaWdub3JlU2Nyb2xsVG9Ub3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc1Njcm9sbGluZ0Rvd24gPSBzY3JvbGxUb3AgPiBsYXN0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxpbmdVcCA9IHNjcm9sbFRvcCA8IGxhc3RTY3JvbGxUb3A7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYW5pbWF0aW9uPy5pZ25vcmVFc2NhcGVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2Nyb2xsVG9wID0gbGFzdFNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTY3JvbGxpbmdVcCkge1xuICAgICAgICAgICAgICAgIHNldEVzY2FwZWRGcm9tTG9jayh0cnVlKTtcbiAgICAgICAgICAgICAgICBzZXRJc0F0Qm90dG9tKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Njcm9sbGluZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICBzZXRFc2NhcGVkRnJvbUxvY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5lc2NhcGVkRnJvbUxvY2sgJiYgc3RhdGUuaXNOZWFyQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNBdEJvdHRvbSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMSk7XG4gICAgfSwgW3NldEVzY2FwZWRGcm9tTG9jaywgc2V0SXNBdEJvdHRvbSwgc3RhdGVdKTtcbiAgICBjb25zdCBoYW5kbGVXaGVlbCA9IHVzZUNhbGxiYWNrKCh7IHRhcmdldCwgZGVsdGFZIH0pID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgICAgIHdoaWxlICghW1wic2Nyb2xsXCIsIFwiYXV0b1wiXS5pbmNsdWRlcyhnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93KSkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYnJvd3NlciBtYXkgY2FuY2VsIHRoZSBzY3JvbGxpbmcgZnJvbSB0aGUgbW91c2Ugd2hlZWxcbiAgICAgICAgICogaWYgd2UgdXBkYXRlIGl0IGZyb20gdGhlIGFuaW1hdGlvbiBpbiBtZWFudGltZS5cbiAgICAgICAgICogVG8gcHJldmVudCB0aGlzLCBhbHdheXMgZXNjYXBlIHdoZW4gdGhlIHdoZWVsIGlzIHNjcm9sbGVkIHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNjcm9sbFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICBkZWx0YVkgPCAwICYmXG4gICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQgPiBzY3JvbGxSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgJiZcbiAgICAgICAgICAgICFzdGF0ZS5hbmltYXRpb24/Lmlnbm9yZUVzY2FwZXMpIHtcbiAgICAgICAgICAgIHNldEVzY2FwZWRGcm9tTG9jayh0cnVlKTtcbiAgICAgICAgICAgIHNldElzQXRCb3R0b20oZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW3NldEVzY2FwZWRGcm9tTG9jaywgc2V0SXNBdEJvdHRvbSwgc3RhdGVdKTtcbiAgICBjb25zdCBzY3JvbGxSZWYgPSB1c2VSZWZDYWxsYmFjaygoc2Nyb2xsKSA9PiB7XG4gICAgICAgIHNjcm9sbFJlZi5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XG4gICAgICAgIHNjcm9sbFJlZi5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgaGFuZGxlV2hlZWwpO1xuICAgICAgICBzY3JvbGw/LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHNjcm9sbD8uYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGhhbmRsZVdoZWVsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGNvbnRlbnRSZWYgPSB1c2VSZWZDYWxsYmFjaygoY29udGVudCkgPT4ge1xuICAgICAgICBzdGF0ZS5yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldmlvdXNIZWlnaHQ7XG4gICAgICAgIHN0YXRlLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChbZW50cnldKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gZW50cnkuY29udGVudFJlY3Q7XG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gaGVpZ2h0IC0gKHByZXZpb3VzSGVpZ2h0ID8/IGhlaWdodCk7XG4gICAgICAgICAgICBzdGF0ZS5yZXNpemVEaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZXRpbWVzIHRoZSBicm93c2VyIGNhbiBvdmVyc2Nyb2xsIHBhc3QgdGhlIHRhcmdldCxcbiAgICAgICAgICAgICAqIHNvIGNoZWNrIGZvciB0aGlzIGFuZCBhZGp1c3QgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNjcm9sbFRvcCA+IHN0YXRlLnRhcmdldFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNjcm9sbFRvcCA9IHN0YXRlLnRhcmdldFNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzTmVhckJvdHRvbShzdGF0ZS5pc05lYXJCb3R0b20pO1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIGl0J3MgYSBwb3NpdGl2ZSByZXNpemUsIHNjcm9sbCB0byB0aGUgYm90dG9tIHdoZW5cbiAgICAgICAgICAgICAgICAgKiB3ZSdyZSBhbHJlYWR5IGF0IHRoZSBib3R0b20uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gbWVyZ2VBbmltYXRpb25zKG9wdGlvbnNSZWYuY3VycmVudCwgcHJldmlvdXNIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zUmVmLmN1cnJlbnQucmVzaXplXG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9uc1JlZi5jdXJyZW50LmluaXRpYWwpO1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvQm90dG9tKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB3YWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVNjcm9sbFBvc2l0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uID09PSBcImluc3RhbnRcIiA/IHVuZGVmaW5lZCA6IFJFVEFJTl9BTklNQVRJT05fRFVSQVRJT05fTVMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbHNlIGlmIGl0J3MgYSBuZWdhdGl2ZSByZXNpemUsIGNoZWNrIGlmIHdlJ3JlIG5lYXIgdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAqIGlmIHdlIGFyZSB3YW50IHRvIHVuLWVzY2FwZSBmcm9tIHRoZSBsb2NrLCBiZWNhdXNlIHRoZSByZXNpemVcbiAgICAgICAgICAgICAgICAgKiBjb3VsZCBoYXZlIGNhdXNlZCB0aGUgY29udGFpbmVyIHRvIGJlIGF0IHRoZSBib3R0b20uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzTmVhckJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRFc2NhcGVkRnJvbUxvY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJc0F0Qm90dG9tKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCB0aGUgcmVzaXplIGRpZmZlcmVuY2UgYWZ0ZXIgdGhlIHNjcm9sbCBldmVudFxuICAgICAgICAgICAgICogaGFzIGZpcmVkLiBSZXF1aXJlcyBhIHJBRiB0byB3YWl0IGZvciB0aGUgc2Nyb2xsIGV2ZW50LFxuICAgICAgICAgICAgICogYW5kIGEgc2V0VGltZW91dCB0byB3YWl0IGZvciB0aGUgb3RoZXIgdGltZW91dCB3ZSBoYXZlIGluXG4gICAgICAgICAgICAgKiByZXNpemVPYnNlcnZlciBpbiBjYXNlIHRoZSBzY3JvbGwgZXZlbnQgaGFwcGVucyBhZnRlciB0aGVcbiAgICAgICAgICAgICAqIHJlc2l6ZSBldmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2l6ZURpZmZlcmVuY2UgPT09IGRpZmZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnJlc2l6ZURpZmZlcmVuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLnJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGNvbnRlbnQpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50UmVmLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvQm90dG9tLFxuICAgICAgICBzdG9wU2Nyb2xsLFxuICAgICAgICBpc0F0Qm90dG9tOiBpc0F0Qm90dG9tIHx8IGlzTmVhckJvdHRvbSxcbiAgICAgICAgaXNOZWFyQm90dG9tLFxuICAgICAgICBlc2NhcGVkRnJvbUxvY2ssXG4gICAgICAgIHN0YXRlLFxuICAgIH07XG59O1xuZnVuY3Rpb24gdXNlUmVmQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBub3QgbmVlZGVkXG4gICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FsbGJhY2soKHJlZikgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudCA9IHJlZjtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlZik7XG4gICAgfSwgZGVwcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGFuaW1hdGlvbkNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gbWVyZ2VBbmltYXRpb25zKC4uLmFuaW1hdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLkRFRkFVTFRfU1BSSU5HX0FOSU1BVElPTiB9O1xuICAgIGxldCBpbnN0YW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBhbmltYXRpb24gb2YgYW5pbWF0aW9ucykge1xuICAgICAgICBpZiAoYW5pbWF0aW9uID09PSBcImluc3RhbnRcIikge1xuICAgICAgICAgICAgaW5zdGFudCA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFuaW1hdGlvbiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQuZGFtcGluZyA9IGFuaW1hdGlvbi5kYW1waW5nID8/IHJlc3VsdC5kYW1waW5nO1xuICAgICAgICByZXN1bHQuc3RpZmZuZXNzID0gYW5pbWF0aW9uLnN0aWZmbmVzcyA/PyByZXN1bHQuc3RpZmZuZXNzO1xuICAgICAgICByZXN1bHQubWFzcyA9IGFuaW1hdGlvbi5tYXNzID8/IHJlc3VsdC5tYXNzO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgIGlmICghYW5pbWF0aW9uQ2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FjaGUuc2V0KGtleSwgT2JqZWN0LmZyZWV6ZShyZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbnQgPyBcImluc3RhbnRcIiA6IGFuaW1hdGlvbkNhY2hlLmdldChrZXkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-stick-to-bottom/dist/useStickToBottom.js\n");

/***/ })

};
;